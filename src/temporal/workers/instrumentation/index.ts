/**
 * Imports
 */
import 'dotenv/config';

import { appendDefaultInterceptors,
  DefaultLogger,
  defaultSinks,
  Logger,
  LogLevel,
  LogMetadata,
  makeTelemetryFilterString,
  Runtime,
  Worker 
} from '@temporalio/worker';
import { TemporalSingleton } from '../../client';
import { getDataConverter } from '../../encryption/data-converter';
import * as activities from './activities';
import { ActivityInboundLogInterceptor } from './interceptors';
import { createLogger } from './logging'

const logger = createLogger({
  isProduction: process.env.NODE_ENV === 'production',
  logFilePath: process.env.WORKER_LOG_PATH || '/var/log/worker.log',
});

async function run() {
  // Create loggers with different labels for the separate components
  const workerWinstonLogger = logger.child({ label: 'worker' });
  const workflowWinstonLogger = logger.child({ label: 'workflow' });
  const activityWinstonLogger = logger.child({ label: 'activity' });

  Runtime.install({
    // Install a logger to collect logs generated by Node.js Workers and Rust Core.
    logger: new DefaultLogger('DEBUG', (entry) => {
      workerWinstonLogger.log({
        level: entry.level.toLowerCase(),
        message: entry.message,
        timestamp: Number(entry.timestampNanos / 1_000_000n),
        ...entry.meta,
      });
    }),
    // Telemetry options control how logs, metrics and traces are exported out of Rust Core
    telemetryOptions: {
      // To export metrics and traces using the OpenTelemetry Collector, set `tracing.otel` or `metrics.otel`.
      // see https://opentelemetry.io/docs/collector/getting-started/ for more information.
      //
      // Expose a port for Prometheus to collect metrics from Core.
      // You can verify metrics are exported with `curl -fail localhost:9464/metrics`.
      metrics: {
        prometheus: { bindAddress: '0.0.0.0:9464' },
      },
      // By default, Core logs go directly to console.
      logging: {
        // What level, if any, logs should be forwarded from Rust Core to the Node.js logger.
        filter: makeTelemetryFilterString({ core: 'DEBUG' }),
        forward: {},
      },
    },
  });

  const workflowLogger: Logger = {
    log(level: LogLevel, message: string, meta?: LogMetadata) {
      workflowWinstonLogger.log(message, meta);
    },
    trace(message: string, meta?: LogMetadata) {
      workflowWinstonLogger.verbose(message, meta);
    },
    debug(message: string, meta?: LogMetadata) {
      workflowWinstonLogger.debug(message, meta);
    },
    info(message: string, meta?: LogMetadata) {
      workflowWinstonLogger.info(message, meta);
    },
    warn(message: string, meta?: LogMetadata) {
      workflowWinstonLogger.warn(message, meta);
    },
    error(message: string, meta?: LogMetadata) {
      workflowWinstonLogger.error(message, meta);
    },
  };

  const isMTLS = process.env.MTLS === 'true';
  const isENCRYPTION = process.env.ENCRYPTION === 'true';
  const namespace = isMTLS ? process.env.TEMPORAL_NAMESPACE : 'default';
  const taskQueue = process.env.EXAMPLE_TASK_QUEUE ? process.env.EXAMPLE_TASK_QUEUE : 'example-queue';
  const connection = await TemporalSingleton.getNativeConnection();

  const worker = await Worker.create({
    connection,
    namespace,
    workflowsPath: require.resolve('./workflows'),
    activities,
    taskQueue,
    interceptors: appendDefaultInterceptors(
      {
        activityInbound: [(ctx) => new ActivityInboundLogInterceptor(ctx, activityWinstonLogger)],
        // workflowModules: [require.resolve('./workflows/interceptors')],
      },
      workflowLogger
    ),
    // Inject sinks
    sinks: defaultSinks(workflowLogger),
    ...(isENCRYPTION && {dataConverter: await getDataConverter()})
  });
  console.log('Worker connection successfully established');

  await worker.run();
  await connection.close();
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
